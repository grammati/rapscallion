The Rapscallion XML templating language
    
    Rapscallion is a template language inspired primarily by Genshi (http://genshi.edgewall.org).
    
    Goals:
      * Scales up. Able to generate XML according to very complex rules without becoming spaghetti.
      * Scales down. Simple templating tasks, such as those needed for HTML generation a-la Rails/ERB et al.
    
    Motivation:
      In working on a project that involved generating many large XML files according to complex and
      ever-changing logic, I experienced two approaches. 
      
      The first put the majority of the logic into
      XSLT files, using code only to produce as input a simple XML \"snapshot\" of the input data (a
      tree-like object model). This quickly degenerated into a mass of unreadable and incomprehensible
      XSL. The problem was that there was an invisible barrier between the world of code (C++, in this
      case) and the world of XSL. Once the XML \"snapshot\" was produced, there was no going back - the
      XSL could not call back into the C++ world. This lead to a never-ending series of hacks to encode
      extra little nuggets of information into the input XML, or the use convoluted XSL tricks to deduce
      the missing information.
      
      The second approach was an overreaction to the first - the entire XML result was produced as an
      in-memory DOM. This solved the problems of the first approach, in that we always had access to 
      any information from the \"code world\" - we could stop and call arbitrarily complex functions
      at any point in the process of creating the DOM - but introduced the problem that the structure
      of the XML we were producing become completely obscured in reams and reams of code. Making even
      simple changes to the XML output involved hunting through the code, and possibly adding several
      new classes and many new lines of code
      
      I always thought the solution here was a judicious combination of a clean programming language
      with a flexible templating system, allowing logic to be carefully allocated to the place where
      it would be the clearest. Python + Genshi was my top choice. But I had come to want a few
      things from my template language that I had not seen available anywhere, and I also started to
      get that \"hacker itch\" that I could only scratch by trying it out for myself.
      
    Features:
      Simple interface: call (rap/render template context), where context is a map and template is
      a filename, string of XML, or pre-compiled template, and get back a string
      
      (compile-template t) returns a compiled template, which is simply a fn.
      
      (render t c) is a convenient way of saying (to-xml-string ((compile-template t) c))
      
      ${foo} in a template is replaced with (str foo) in most cases - actually foo is passed
      to the multimethod xml-value, which calls (str foo) for simple types
      
    Directives:
      rap:for, rap:let
      rap:match, rap:defn, rap:call
      
      Call-with-context, as in Mako. TODO - decide how this will work.
      
    Brain-dump:
      What should 'context' be? How should missing values be handled? Configurable.
      Substitutions: ${foo} should subsitute (str foo) in simple cases, but what about if foo is
      some sort of data structure? How to recognize when foo is returning a seq of xml-events?
      Compile-time constants? Eg: to support compiling per-locale versions, for fast l17n.
      Debugging - make it possible to dump the generated code. Include line-numbers, or even
      the actual lines from the template as comments.
      
  
Code layout:
  rapscallion.xml:
    parser (if I need it - prefer not to, but clojure.xml ignores comments, PIs, etc...)
    Element type
    elment utilities (eg: assoc-attr, etc)
  rapscallion.template.text:
    text templates?
  rapscallion.template.xml
    rendering
  rapscallion.compiler
    template compilation?

Usage:
  Simplest: (render tmpl input) => string
  or: (render tmpl input *out*) => write (incrementally?)
  compilation: (compile-template string-or-reader)
  filter templates: (my-filter generated-xml [context])
  or: (-> context template filter-1 filter-2) => element
  or: (build-template template filter-1 filter-2) => fn

Random:
  Template cache? With file-system watch? (out-of-scope?)
  







